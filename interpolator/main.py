# -*- coding: utf-8 -*-
"""Untitled9.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JprzlKkUmpOGPCrSFSoohLmk9OJzHfNi
"""

import json
import cv2
import numpy as np

def load_json_data(file_path):
    with open(file_path, 'r') as f:
        return json.load(f)

def interpolate_missing_frames(data):
    frames = sorted([int(k) for k in data.keys()])
    interpolated_data = {}

    for i in range(frames[0], frames[-1] + 1):
        if str(i) in data:
            interpolated_data[i] = data[str(i)]
        else:
            # Find the nearest known frames before and after
            prev_frame = max([f for f in frames if f < i])
            next_frame = min([f for f in frames if f > i])

            # Linear interpolation
            prev_data = data[str(prev_frame)]
            next_data = data[str(next_frame)]
            alpha = (i - prev_frame) / (next_frame - prev_frame)

            interpolated_data[i] = {
                'x_center': prev_data['x_center'] + alpha * (next_data['x_center'] - prev_data['x_center']),
                'y_center': prev_data['y_center'] + alpha * (next_data['y_center'] - prev_data['y_center']),
                'smoothened_speed': prev_data['smoothened_speed'] + alpha * (next_data['smoothened_speed'] - prev_data['smoothened_speed']),
                'is_at_rest': prev_data['is_at_rest']  # We can't interpolate boolean values, so we'll use the previous frame's value
            }

    return interpolated_data

def draw_trajectory(video_path, interpolated_data, output_path):
    cap = cv2.VideoCapture(video_path)
    width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
    height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
    fps = int(cap.get(cv2.CAP_PROP_FPS))

    fourcc = cv2.VideoWriter_fourcc(*'mp4v')
    out = cv2.VideoWriter(output_path, fourcc, fps, (width, height))

    frame_number = 0
    trajectory = []

    while True:
        ret, frame = cap.read()
        if not ret:
            break

        if frame_number in interpolated_data:
            data = interpolated_data[frame_number]
            x, y = int(data['x_center']), int(data['y_center'])
            trajectory.append((x, y))

        # Draw the entire trajectory up to this point
        for i in range(1, len(trajectory)):
            cv2.line(frame, trajectory[i-1], trajectory[i], (0, 255, 0), 2)

        # Draw the current point
        if trajectory:
            cv2.circle(frame, trajectory[-1], 5, (0, 0, 255), -1)

        out.write(frame)
        frame_number += 1

    cap.release()
    out.release()

def main():
    json_file_path = 'tracking_data.json'
    video_path = 'drop.mp4'
    output_path = 'output_trajectory_video.mp4'

    data = load_json_data(json_file_path)
    interpolated_data = interpolate_missing_frames(data)
    draw_trajectory(video_path, interpolated_data, output_path)

if __name__ == "__main__":
    main()